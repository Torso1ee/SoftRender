### 这是基于[tinyrenderer](https://github.com/ssloy/tinyrenderer "tinyrenderer")实现的cpu渲染

### 以下是渲染原理要点

### 齐次坐标和各种变换

**齐次坐标**是一种扩展的坐标表示法，用于方便描述和计算仿射变换和投影变换

* 在二维空间中，一个点 (x,y)(x, y)**(**x**,**y**)** 的齐次坐标表示为 (x,y,w)，其中 w≠0
* 在三维空间中，一个点 (x,y,z)(x, y, z)**(**x**,**y**,**z**)** 的齐次坐标表示为 (x,y,z,w)，其中 w≠0
* 实际坐标通过除以 w 得到

#### 各种变换（以二维坐标系为例）

**缩放变换**：x->a×x,y->b×y

$$
\begin{bmatrix}
a & 0 \\
0 & b
\end{bmatrix}
$$

**旋转矩阵**：绕原点转θ度

$$
\begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}
$$

**剪切变换**：沿着某个轴“倾斜”

$$
\begin{bmatrix}
1 & k \\
0 & 1
\end{bmatrix}
$$

**为什么需要使用齐次坐标？**

**平移变换**：x->x+a,y->y+b

显然无法用2*2矩阵表达，因为并非线性

通过齐次坐标，把平移因子[a,b,1]作为新的一列，转化成线性变换

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
=
\begin{bmatrix}
x + a \\
y + b \\
1
\end{bmatrix}
$$

**仿射变换** 是一种包括线性变换（旋转、缩放、剪切）和**平移**的组合变换。

### 六种空间和四种变换

**模型空间坐标系（Model Space）**

    ↓**模型变换（Model Transformation）**：负责将物体从模型坐标系（局部坐标系）变换到世界坐标系

**世界坐标系（World Space）**

    ↓**视图变换（View Transformation）**：负责将世界坐标系转换到相机坐标系（观察者坐标系）

**相机坐标系（Camera Space）**

    ↓**投影变换（Projection Transformation）**：负责将相机坐标系中的三维场景投影到裁剪空间

**裁剪空间坐标系**:裁剪空间是图形管线中顶点经过投影变换后得到的坐标空间，顶点以齐次坐标形式表示（x, y, z, w）。在这个空间内，顶点会被裁剪以去除视锥体外的部分，从而优化后续渲染。

    ↓**透视除法（Perspective Divide）**：将裁剪空间坐标转换为标准化设备坐标（NDC）

**标准化设备坐标系（Normalized Device Coordinates (NDC)）**：标准化设备坐标系是将裁剪空间经过齐次除法（Perspective Divide）后得到的坐标空间，所有坐标都被规范化到 [−1,1]的立方体内。

    ↓**视窗变换（Viewport Transformation）**：将标准化设备坐标映射到屏幕坐标系

**屏幕空间（Screen Space）**

### 怎样画一条直线

#### Bresenham’s Line Drawing Algorithm

是一个经典的  **栅格化直线绘制算法** ，用于在像素网格中高效地绘制一条近似直线。它以  **整数运算为主** ，效率很高，广泛用于图形学与嵌入式图形显示。

![1747313871375](image/readme/1747313871375.png)

假设绘制直线[x0,y0]->[x1,y1]，斜率≤1

1. 首先计算误差 dx = x1-x0 dy = y1-y0
2. 设累计误差 p= 2dy-dx
3. 初始化[x,y] = [x0,y0]
4. 从x0->x1，绘制点[x,y]，若p≥0，y+=1,p+=2dy-2dx,否则p=p+2dy

**为什么是2dy-dx?**

抛开这个值不管，考虑用浮点数去描述这个误差，怎么描述呢？想象绘制一个像素就是绘制一段长度为1的直线，而直线斜率为dy/dx，每次累计误差dy/dx，随着x0->x1，为了维持直线的形状，如果累计误差>0.5，就令y+=1，p-=1。看看描述这个条件的不等式：dy/dx≤0.5，即2dy-dx≤0，由于整形运算较快，用这个误差去累计效率更高。

**斜率＞1？**

可以把xy反过来计算误差，绘制时再反过来绘制

### 怎样绘制一个三角面：三角形光栅化

#### Old-school method: Line sweeping(传统派王源)

是在现代光栅化技术（如 barycentric 插值、GPU 流程）出现前，**用扫描线逐行填充三角形的方法**

#### 原理概述：Line Sweeping Rasterization

给定一个三角形三个顶点 `v0(x0, y0)`、`v1(x1, y1)`、`v2(x2, y2)`，我们按照如下步骤执行：

##### 1. 按 y 坐标排序顶点：

![1747315586726](image/readme/1747315586726.png)

此时：

* `v0` 是最上面的点
* `v1` 是中间点
* `v2` 是最下面的点

##### 2. 将三角形分成两个部分：

* **上半部分** ：v0 到 v1
* **下半部分** ：v1 到 v2

每一部分可以看作是两个顶点间的一条扫描线逐步水平填充。

![1747315765478](image/readme/1747315765478.png)

注意边缘情况 v1.y = v0. y 和 v1.y = v2.y

#### Bounding Box + Barycentric Coordinates(维新派丁真)

基于 **Bounding Box + 重心坐标（Barycentric Coordinates）** 的三角形光栅化，是现代软件渲染器中最常见、也是最优雅的一种方法。它对纹理贴图、Z-buffer、阴影映射等扩展非常友好。

![1747316102011](image/readme/1747316102011.png)

对绘制的三角形取一个boundingbox，对box内每个像素进行测试，重心坐标xyz都大于0等于的像素就是在三角形里面，需要绘制。

### 隐藏面剔除(z-buffer)

Z缓冲（Z-buffer）是现代光栅化渲染中最常用的 **隐藏面消除技术** ，用于判断哪个片元（像素）在视点前面、该被显示出来。它解决的是“多个三角形重叠时，前面的遮挡后面的”问题。

Z-buffer 存储每个像素当前的最小深度值（Z 值），每绘制一个像素就判断是否更近，如果更近就更新它，否则丢弃。

![1747316512886](image/readme/1747316512886.png)

如图，假设zbuffer中p0对应的像素位置缓存了p0.z，而下回某次绘制，某个p1变换到跟p0一样的像素位置，比较p1.z和缓存值决定是否更新缓存和绘制这个像素。

### Shader着色器

#### **GPU渲染管线流程**

![1747278733105](image/readme/1747278733105.png)

主要介绍VertexShader和Pixel Shader(Fragment Shader )

#### **VertexShader**

**顶点着色器**是图形管线中的一个可编程阶段，负责处理每个顶点的数据。它的主要任务包括：

* 变换顶点坐标（如模型变换、视图变换、投影变换）
* 计算顶点的法线、颜色、纹理坐标等属性
* 输出变换后的顶点位置给后续管线阶段（如图元装配和光栅化）

#### **Pixel Shader**

**片元着色器（有时也叫像素着色器**）是图形渲染管线中的一个阶段，用于计算每个片元（像素候选点）的最终颜色和其他属性。它通常用于：

* 计算光照效果
* 纹理采样与映射
* 颜色混合与处理
* 透明度和其他像素级效果

### 一个简单的渲染流程

#### 计算变换矩阵

假设模型不需要变换直接在世界坐标系下渲染

**视图变换**

首先相机有一个向量up，一般朝上，先确定z方向，z=center(视点)-eye(相机位置)，单位化，用z和up叉积求x，单位化，z和x叉积求y，单位化。现在可以构造正交矩阵[x,y,z]，世界坐标系变换到相机坐标系，S=invert(C)*B，C构成相机坐标系的正交标准基即[x,y,z]，B为世界坐标系的标准基为单位阵，正交矩阵的逆为其转置，S=transpose(C)。等等，别忘了相机并不是在原点，坐标变换过去后要减去相机中心center，用齐次坐标描述这个变换，4*4矩阵View，左上3*3块为S，最后一列为[center ,1]

![1747318208357](image/readme/1747318208357.png)

**投影变换**

//TODO

**透视除法**

**视窗变换**

设视窗宽为w，高为h，左下角为[x,y]，则ndc为[-1,1]，应该先x，y方向分别缩放w/2，h/2倍，此时左下角为[-w/2,-h/2]，移动到目标的左下角，移动向量为[w/2+x,h/2+y]

![1747318821670](image/readme/1747318821670.png)

#### Vertex Shader里进行坐标变换

计算输入点在裁剪空间的齐次坐标，从世界坐标系到裁剪空间（假设原物体不进行模型变换），变换矩阵为Projection*View

//TODO

#### 栅格化

获取到点在裁剪空间的齐次坐标后，映射到屏幕空间

#### **Pixel Shader**里计算像素颜色

//TODO

### 法线贴图

### 阴影贴图

### 环境光遮蔽
